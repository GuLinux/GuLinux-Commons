#!/bin/bash

################################ Snippet for calculating movie hash from opensubtitles
#  Copyright (C) 
# 2014 - Tomasz Wisniewski dagon666
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.


correct_64bit() {
	local pow32=$(( 1 << 32 ))

	while [ "$g_lo" -ge $pow32 ]; do
		g_lo=$(( g_lo - pow32 ))
		g_hi=$(( g_hi + 1 ))
	done
	while [ "$g_hi" -ge $pow32 ]; do
		g_hi=$(( g_hi - pow32 ))
	done
}


hash_part() {
	local file="$1"
	local curr=0
	local dsize=$((8192*8))

	local bytes_at_once=2048
	local groups=$(( (bytes_at_once / 8) - 1 ))
	local k=0
	local i=0
	local offset=0
	declare -a num=()

	while [ "$curr" -lt "$dsize" ]; do
		num=( $(od -t u1 -An -N "$bytes_at_once" -w$bytes_at_once -j "$curr" "$file") )

		for k in $(seq 0 $groups); do

			offset=$(( k * 8 ))

			g_lo=$(( g_lo + \
				num[$(( offset + 0 ))] + \
				(num[$(( offset + 1 ))] << 8) + \
				(num[$(( offset + 2 ))] << 16) + \
				(num[$(( offset + 3 ))] << 24) ))

			g_hi=$(( g_hi + \
				num[$(( offset + 4 ))] + \
				(num[$(( offset + 5 ))] << 8) + \
				(num[$(( offset + 6 ))] << 16) + \
				(num[$(( offset + 7 ))] << 24) ))

			correct_64bit
		done

		curr=$(( curr + bytes_at_once ))
	done
}


hash_file() {
	g_lo=0
	g_hi=0

	local file="$1"
	local size=$(stat -c%s "$file")
	local offset=$(( size - 65536 ))

	local part1=$(mktemp part1.XXXXXXXX)
	local part2=$(mktemp part2.XXXXXXXX)

	dd if="$file" bs=8192 count=8 of="$part1" 2> /dev/null
	dd if="$file" skip="$offset" bs=1 of="$part2" 2> /dev/null

	hash_part "$part1"
	hash_part "$part2"

	g_lo=$(( g_lo + size ))
	correct_64bit

	unlink "$part1"
	unlink "$part2"

	printf "%08x%08x\n" $g_hi $g_lo
}

################################################################ End of OpenSubtitles snippet 

function getv() {
#   echo "getv $@" >&2
  eval echo \$$@
}

function optionsFor_data() {
	true
}

function indexes_of() {
  local ref=$1[@]
  cnt=0
  for i in "${!ref}"; do echo -en "$cnt "; cnt=$((cnt+1)); done
}

function optionsFor_video() {
  if test "x$force_video_recoding" == "xyes"; then
    case "$video_recoding_quality" in
      "low")
        echo "-c:$1 libx264 -preset veryfast -crf 35"
        ;;
      "average")
        echo "-c:$1 libx264 -preset medium -crf 24"
        ;;
      "good")
        echo "-c:$1 libx264 -preset slow -crf 21"
        ;;
      "insane")
        echo "-c:$1 libx264 -preset veryslow -crf 17"
        ;;
    esac          
    return
  fi

  if test "x$2" == "xh264"; then
    return
  fi
  echo "Error! codec $2 not yet supported; exiting (use --force-video-recoding to try anyway)" >&2
  exit 1

}

function optionsFor_attachment() {
  true
}

function optionsFor_audio() {
	if test "x$2" == "xaac"; then
		return
	fi
	echo "-c:$1 libfdk_aac -b:$1 192k"
}

function optionsFor_subtitle() {
	if echo "$3" | grep -q "mov_text" || test "x$2" == "xmov_text"; then
		return
	fi
	echo "-c:s mov_text"
	#echo "-c:$1 mov_text"
}

function do_help() {
  echo "Usage: $0 file[s] [options]"
  echo "Options: "
  echo -e "-p|--pretend|shows the command to be executed, without running it
-f|--force-reorder|forces tracks reorder
-d <dir>|--output-dir <dir>|forces tracks reorder
-t <title>|--title <title>|sets title for this media
-a|--ask-media-title|asks the user for the title
-l|--force-ask-language|asks the user for subtitles language
-s <suffix>|--suffix <suffix>|adds a suffix to the autogenerated filename
-o <file path>|--output <file path>|manually sets the output file
-ve|--force-video-recoding|force video track reencoding (usually discouraged)
-vq|--video-recoding-quality|video recoding quality (low, average, good, insane)
" | column -t -s'|'
  exit 1
}

video_recoding_quality="good"
set -e

progress_info="/tmp/$(basename "$0").progress.info"
if test "x$1" == "x--progress"; then
	eval "$( grep info_ "$progress_info" )"
	tail -f "$progress_info" --pid=$info_pid | dialog --gauge "$0 progress info" 20 120
	clear
	exit 0
fi



while [ -r "$1" ]; do
  files+=("$1"); shift
done
if test ${#files[@]} -lt 1; then
	echo "Error: found ${#files[@]} input files"
	do_help
fi

echo "Found ${#files[@]} input files: ${files[@]}"

opensubtitles_hash="$( hash_file "${files[0]}")"
echo "OpenSubtitles hash for ${files[0]}: $opensubtitles_hash"


need_reorder="false"
pretend="false"
set_media_title="false"
out_dir="$( dirname "$( readlink -f "${files[0]}")" )"

while test "x$1" != "x"; do
  case "$1" in
    "-f"|"--force-reorder")
      need_reorder="true"
      ;;
    "-p"|"--pretend")
      pretend="true"
      ;;
     "-a"|"--ask-media-title")
      set_media_title="true"
      ;;
     "-t"|"--title")
      shift
      set_media_title="$1"
      ;;
     "-l"|"--force-ask-language")
      FORCE_LANGUAGE_ASK="true"
      ;;
      "-d"|"--output-dir")
      shift
      if ! [ -d "$1" ]; then
	do_help
      fi
      out_dir="$( readlink -f "$1")"
      ;;
    "-ve"|"--force-video-recoding")
      force_video_recoding="yes"
      ;;
    "-vq"|"--video-recoding-quality")
      case "$2" in
        "low"|"average"|"good"|"insane")
        video_recoding_quality="$2"
        shift
        ;;
        *)
        do_help
        ;;
      esac
      ;;
    "-s"|"--suffix")
      shift
      filename_suffix="$1"
      test "$filename_suffix" == "" && do_help
      ;;
    "-o"|"--output")
      shift
      forced_output="$1"
      test "$forced_output" == "" && do_help
      ;;
      *)
      do_help
      ;;
  esac
  shift
done

for i in `indexes_of files`; do
  eval "$( ffprobe -loglevel quiet -of flat=sep_char=_ -show_format -show_streams "${files[$i]}" | sed "s/^/file_${i}_/g" )"
done

echo "streams: ${format_nb_streams[@]}"
for file in `indexes_of files`; do
  indexes[$file]=`seq 0 $(( $( getv file_${file}_format_nb_streams) - 1 )) | tr '\n' ' '`
done


function slang() {
  getv file_$(cut -f1 -d: <<<$1)_streams_stream_$(cut -f2 -d: <<<$1)_tags_language
}
function stype() {
  getv file_$(cut -f1 -d: <<<$1)_streams_stream_$(cut -f2 -d: <<<$1)_codec_type
}
function scodec() {
  getv file_$(cut -f1 -d: <<<$1)_streams_stream_$(cut -f2 -d: <<<$1)_codec_name
}
function stitle() {
  getv file_$(cut -f1 -d: <<<$1)_streams_stream_$(cut -f2 -d: <<<$1)_tags_title
}

streams_summary="Track|Type|Language|Title|Codec|File"

for file in `indexes_of files`; do
  for index in ${indexes[$file]}; do
    map_index="${file}:${index}"
    map_indexes+=($map_index)
    streams_summary="$streams_summary\n$map_index|\"$(stype $map_index)\"|\"$(slang $map_index)\"|\"$(stitle $map_index)\"|\"$(scodec $map_index)\"|${files[$file]}"
  done
done

echo -e "$streams_summary" | column -t -s '|'


if test "x$need_reorder" == "xtrue"; then
  echo "Reordering streams"
  for i in `indexes_of map_indexes`; do
    read -e -i ${map_indexes[$i]} -p "Stream at index #${i} (enter to remove stream): " new_stream
    if test -z "$new_stream"; then break; fi
    map_indexes_out+=($new_stream)
  done
else
  for i in `indexes_of map_indexes`; do
    map_indexes_out+=(${map_indexes[$i]})
  done
fi

media_title="$file_0_format_tags_title"
if test "$set_media_title" != "false" && test "$set_media_title" != "true"; then
  media_title="$set_media_title"
fi
if test -z "$media_title" || test "$set_media_title" == "true"; then
  if test "$media_title" == ""; then media_title="$( basename "${files}[0]")"; fi
  read -e -i "${media_title}" -p "Media Title: " media_title
fi


#ffmpeg_options="-cpu-used 0 -threads 12 -c copy"
NUM_THREADS="$(( $( cat /proc/cpuinfo | grep processor| wc -l ) * 2 ))"
ffmpeg_options="-threads $NUM_THREADS -c copy -c:s mov_text"

for stream in ${map_indexes_out[@]}; do
  ffmpeg_options="$ffmpeg_options -map $stream"
done

index=0
for stream in ${map_indexes_out[@]}; do
	stream_type="$(stype $stream)"
	codec="$(scodec $stream)"
	lang="$(slang $stream)"
	title="$(stitle $stream)"
	echo "Stream # $stream -> $index: type $stream_type, codec: $codec, lang: $lang, title: $title"
	ffmpeg_options="$ffmpeg_options $( optionsFor_$stream_type $index $codec "$ffmpeg_options" )"
	index=$(( $index + 1 ))
done

metadata_opts="-metadata title=\"$media_title\" -metadata comment=\"opensubtitles_original_hash=$opensubtitles_hash\""

filename="$( basename "${files[0]}")"
extension="${filename##*.}"
output_tmp="$out_dir/temp_$( basename "$filename" .$extension).mp4"
auto_output="$out_dir/$( basename "$filename" .$extension)${filename_suffix}.mp4"
output="${forced_output-$auto_output}"

for i in `indexes_of files`; do
  ffmpeg_inputs="$ffmpeg_inputs -i \"${files[$i]}\""
done

index=0
for stream in ${map_indexes_out[@]}; do
  if test -z "$(slang $stream)" || test "$FORCE_LANGUAGE_ASK" == "true"; then
    if test "$FORCE_LANGUAGE_ASK"; then
      read -e -i "$(slang $stream)" -p "stream $stream language: " lang
    else
      read -e -i "$(slang 0:0)" -p "stream $stream language missing: " lang
    fi
    metadata_opts="$metadata_opts -metadata:s:$index language=$lang"
  fi
  index=$(($index+1))
done

set > "/tmp/$( basename "$0").env"
temp_fifo="/tmp/$( basename "$0")_$$.fifo"
rm -f "$temp_fifo"; mkfifo "$temp_fifo"
function rmFifo() {
    rm -f "$temp_fifo"
#    rm -f "$progress_info"
}
trap rmFifo EXIT

function parseFFMPEGProgress() {
    started_time="$1"   
    set -x
    cat "$temp_fifo" | grep out_time_ms --line-buffered |  gawk -F= "{
print \"XXX\"
percent=\$2 / 1000000 * 100 / $file_0_format_duration 
printf \"%.0f\n\",  percent
print \"FFMPeg Muxing in progress for '$(basename "$output")'\"
printf \"%s\", \"File Size: \"; system(\"du -h '$output_tmp' | cut -f1\")
elapsed=systime() - $started_time
remaining=((100-percent)*elapsed/percent)
printf \"Time elapsed: %s, time remaining: %s.\n\", strftime(\"%T\", elapsed, 1), strftime(\"%T\", remaining, 1)
 print \"XXX\"
fflush()
}" >> "$progress_info"
}
function printQtFastStartProgress() {
    procpid="$1"
    started="$2"
    while kill -s 0 $procpid 2>/dev/null && ! [ -r "$output" ]; do sleep 0.1; done
    while kill -s 0 $procpid 2>/dev/null; do
	if ! [ -r "$output_tmp" ] || ! [ -r "$output" ]; then return; fi
        total_size="$( du "$output_tmp" | cut -f1)"
        current_size="$( du "$output" | cut -f1)"
	if ! test $current_size -gt 0 || ! test $total_size -gt 0; then continue; fi
        echo "XXX" >> "$progress_info"
        echo "$current_size $total_size" | gawk '{ printf "%.0f\n", $1 * 100 / $2 }' >> "$progress_info"
        echo "Running qt-faststart on $output" >> "$progress_info"
	echo "File Size: $( du -h "$output_tmp" | cut -f1)" >> "$progress_info"
	echo $started $current_size $total_size| gawk '{
	elapsed=systime() - $1
	remaining=($3 - $2)*elapsed/$2
	printf "Time elapsed: %s, time remaining: %s.\n", strftime("%T", elapsed, 1), strftime("%T", remaining, 1)
}' >> "$progress_info"
	echo "XXX" >> "$progress_info"
	sleep 1
    done
}

if test "$( readlink -f "$output")" == "$( readlink -f "${files[0]}")"; then
  echo "WARNING: input and output file seems to be the same"
  echo "Type \"yes\" to continue"
  read confirmation
  if test "$confirmation" != "yes"; then exit 1; fi
fi

if test "x$pretend" == "xtrue"; then
  echo "ffmpeg $ffmpeg_inputs $ffmpeg_options $metadata_opts \"${output_tmp}\""
  echo "qt-faststart \"$output_tmp\" \"$output\""
  echo "rm \"$output_tmp\""
#  echo "MP4Box -hint $mp4box_options"\"${output}\"
  exit 0
else
  echo "info_pid=$$" >"${progress_info}"
  echo "Muxing in progress. To monitor it, just type \"$0 --progress\" in a new shell"
  parseFFMPEGProgress $( date +%s)&
  set -x
  bash -c "ffmpeg $ffmpeg_inputs $ffmpeg_options $metadata_opts \"${output_tmp}\" -progress \"$temp_fifo\" "
  set +x
  time qt-faststart "$output_tmp" "$output" &
  qt_faststart_pid=$!
  printQtFastStartProgress $qt_faststart_pid $( date +%s ) &
  wait $qt_faststart_pid
  rm "$output_tmp"
  echo -n "Muxing finished: "
  if [ -r "$output" ]; then
    echo "$output correctly written"
  else
    echo "ERROR! $output missing."
  fi
#  bash -c "MP4Box -hint $mp4box_options \"in_${file}.mp4\" -out \"${file}.mp4\""
#  rm "in_${file}.mp4"
fi
#echo -e "$(date +%Y-%m-%d_%H.%M.%S)\t${file}\t${file}.mp4" >> "/tmp/$( basename "$0").log"

